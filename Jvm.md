## Jvm

### Jvm Memory Model

#### 程序计数器 

> 概述: 也被称为Pc寄存器 

> 作用及其特点:
>
> - 当前线程所执行的字节码行号指示器
> - 线程执行Native方法, 程序计数器中的值是undefined
> - 不会出现OutOfMemoryError情况

#### Java栈 

> Java栈是Java方法执行的内存模型

> 每一个栈帧对应一个方法, 栈帧中包括:
>
> - ==局部变量表==: 存储方法中的局部变量, 基础-> 值, 引用类型 -> 对象引用. 大小在编译器确定, 不用改变
> - ==操作数栈==: 用来对象表达式进行求值.
> -  ==指向当前方法所属的类的运行时常量池的引用==: 方法运行时可能需要类中的常量
> - ==方法返回地址==: 执行完一个方法后, 要返回之前调用它的地方

注: ==本地方法栈和Java栈不同==

#### 堆

> 所有线程共享的一块内存区域, 用于存放对象实例, 虚拟机启动时创建.

> 堆分为两个区域:
>
> - 新生代
>   - eden区(占用80%)
>   - s0(From Survivor, 占用10%)
>   - s1(To Survivor, 占用10%)
> - 老年代

#### 方法区

> 方法区和堆一样是线程共享的. 存放每个类的信息, 静态变量, 常量以及编译器编译后的代码等

#### 运行时常量池

> 运行时常量池是方法区的一部分, Class文件中除了有类的版本, 字段, 方法, 接口等信息. 
>
> 还有常量池, 用于存放编译期生成的各种字面量和符号引用, 类加载后进行运行时常量池

> 具有动态性,  运行期间也可以将新的常量放入运行时常量池

#### 疑问

##### 堆区域为什么需要分代?

==分代目的是为了性能优化, 提高GC的效率==

##### 新生代为什么分区?

==不分区, 进行一次Minor GC, 老年代会被快速填满, 会触发Full GC, 因为老年代的内存空间远大于新生代, 进行了一次Full GC的事件比Minor GC 的时间长.==

==Survivor区作用是减少被送往老年代的对象, 进而减少Full GC的发生. Survivor的预筛选保证, 只有经历16次Minor GC还能在新生代中存活的对象, 才会被送到老年代.==

##### 堆如何分配内存?

==空闲列表 -- 指针碰撞==

指针碰撞: 假设Java堆中内存是规整的, 用过的内存放一边, 空闲的放一边, 中间放个指针作为分界点的指示器, 所分配内存就仅仅是把哪个指针向空闲空间那边挪动一段与对象大小相等的举例.这叫==指针碰撞==

空闲列表: 有一个列表, 其中记录中哪些内存块有用, 在分配的时候从列表中找到一块足够大的空间划分给对象实例, 然后更新列表中的记录. 这就叫做==空闲列表==

##### 对象引用如何找到堆中的对象实例?

==句柄访问--直接指针访问==

句柄访问: Java堆中会划分出一块内存作为句柄池. 引用变量中存储的就是对象的句柄地址, 而句柄中包含了对象==实例数据==和==类型数据==各自的具体地址信息.

直接指针访问: 引用变量中存储的就直接是对象地址了

优缺点:

- 使用句柄访问的优点是, 引用变量中存储的是稳定的句柄, 不会随着对象的移动而改变
- 使用直接指针访问的优点是, 速度更快, 节省了一次指针定位的开销, 但对象移动时, 需要改变引用变量地址