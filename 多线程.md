# 多线程

## 线程状态

线程的状态一共有七种:

- 初始化状态 `start`
- 就绪状态 `ready-to-run`
- 运行状态 `running`
- 死亡状态 `dead`
- 等待状态 `waiting` 
- 休眠状态 `sleeping` 
- 阻塞状态 `blocked`

代码:

```java
public class StateTest implements Runnable {

    @Override
    public synchronized void run() {
        while (true) {
            try {
                /*waiting state*/
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("自定义的线程执行了.....");
        }
    }

    public static void main(String[] args) {

        StateTest state = new StateTest();
        /*start state*/
        Thread thread = new Thread(state);
        /*ready-to-run state*/
        thread.start();

        while (true) {
            synchronized (state) {
                System.out.println("main线程执行了.....");
                try {
                    /*sleeping state*/
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                state.notifyAll();
            }
        }
    }
}
```

## 线程创建

- 继承Thread类

代码:

```java

```

- 实现Runnable接口

代码:

```java
class RealizeRunnable implements Runnable {

    @Override
    public void run() {
        System.out.println("realize runnable......");
    }
}
```

- 实现Callable接口

代码:

```java
class RealizeCallable implements Callable<Integer> {

    @Override
    public Integer call() throws Exception {
        System.out.println("realize callable....");
        return Integer.MAX_VALUE;
    }

    public void testRealizeCallable() throws ExecutionException, InterruptedException {

        FutureTask<Integer> futureTask = new FutureTask<>(new RealizeCallable());
        new Thread(futureTask).start();
        Integer result = futureTask.get();
        System.out.println(result);
    }
}
```

- 使用Executors创建线程池

代码:

```java
//创建一个缓存的线程池,线程数自动递增
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
//创建一个线程的线程池
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
//创建一个指定大小的线程池
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
//创建一个指定大小的定时调度线程池
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}
//创建单个线程的定时调度线程池
public static ScheduledExecutorService newSingleThreadScheduledExecutor() {
    return new DelegatedScheduledExecutorService(new ScheduledThreadPoolExecutor(1));
}
```

## 线程安全

- 活跃性问题

  - 死锁
  - 饥饿

  ```java
  public static void main(String[] args) {
      Thread one = new Thread(() -> {
          while (true)
              System.out.println(Thread.currentThread().getName() + ":hunger lock....");
      }, "One");
      Thread two = new Thread(() -> {
          while (true)
              System.out.println(Thread.currentThread().getName() + ":hunger lock....");
      }, "Two");
  	//合理设置优先级
      one.setPriority(1);
      one.start();
      two.start();
  }
  ```

  - 活锁



## 内存模型

###happens-before

- 概述
  - JMM中,如果一个操作执行的结果需要对另一个操作可见,那么两个操作之间==必须存在happens-before==关系

  

- 作用
  - 判断数据是否存在竞争,线程是否安全的主要依据

  

- 定义
  - 如果一个操作happens-before另一个操作, 那么第一个操作结果对第二个操作可见, 第一个操作执行顺序在第二个操作前
  - 两个操作之间存在happens-before关系, 并不意味着一定要按照happens-before原则执行的顺序执行. 如果重排序之后的执行结果与按照happens-before关系执行的结果一致, 那么这种重排序并不合法

  

- happens-before规则:
  - ==程序次序规则==: 一个线程内, 按照代码顺序, 书写在前面的操作先行发生于书写在后面的操作;
  - ==锁定规则==: 一个unLock操作先行发生于后面对同一个锁Lock操作;
  - ==volatile变量规则==: 对一个变量的写操作先行发生于后面对这个对象的读操作;
  - ==传递规则==: 如果操作A先行发生于操作B, 而操作B又先行发生于操作C, 则得出操作A先行发生于操作C 
  - ==线程启动规则==: Thread对象的start()方法先行发生于此线程的每一个动作;
  - ==线程中断规则==: 对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生;
  - ==线程终结规则==: 线程中所有的操作都先行发生于线程的终止检测;
  - ==对象终结规则==: 一个对象的初始化完成先行发生于他的`finalize()方法`的开始;

  

- 推导出的规则:

  - 在CountDownLatch上的倒数操作Happens-Before `CountDownLatch#await()`操作;
  - 释放Semaphore许可的操作Happens-Before获得许可操作;
  - Future表示的任务的所有操作Happens-Before `Future#get()`操作;
  - 向Executor提交一个Runnable或Callable的操作Happens-Before任务开始执行操作;

**注: 如果两个操作不存在上述任意一个happens-before规则, 则这两个操作就没有顺序的保障**

### 重排序

#### as-if-serial语义

- 所有的操作均可以为了优化而被重排序,但是重排序后执行的结果不能被改变, 

- ==多线程无效==

- 编译器, runtime, 处理器必须遵守

- 代码

  - ```java
    Integer a = 1; //A
    Integer b = 2; //B
    Integer c = a + b; //C
    
    //A 和 B不存在数据依赖. A和C B和C存在数据依赖. 
    //执行顺序: A -> B -> C 或 B -> A -> C
    ```

  - ```java
    public class Reorder {
        public static void main(String[] args) {
            Integer a = 1;
            Integer b = 2;
    
            try {
                a = 3;          // A
                b = 1 / 0;      // B
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                System.out.println("a = " + a);
            }
        }
    }
    // 如果发生了重排序, A一定执行不到, 不满足as-if-serial
    // JIT在重排序会在catch语句插入错误代偿代码 (a = 3)
    ```

#### 重排序对多线程影响

结论: **重排序会破坏多线程的执行语义**

代码:

```java
public class Reorder {

    private Integer value = 0;

    private Boolean flag;

    public void write() {
        value = 1;                  // 1
        flag = Boolean.TRUE;        // 2
    }

    public void read() {
        if (flag) {                 // 3
            Integer result = value + value;              // 4
        }
    }
}
```

注: 

- 操作 1 和 2可以重排序, 3 和 4也可以重排序==(存在控制依赖关系)==.
- 当代码中存在控制依赖性时, 会影响指令序列的执行的并行度, 所以编译器和处理器会采用猜测执行来克服控制依赖对并行度的影响.
- 假如操作3 和操作4重排序了, 操作4 先执行, 则先会把计算结果==临时==保存到==重排序缓冲==中, 当操作3 为真时才会将计算结果写入变量result中 

### Volatile

#### volatile与happens-before

代码:

```java
public class Reorder {

    private Integer value = 0;

    private volatile Boolean flag;

    //Thread-A
    public void write() {
        value = 1;                  // 1
        flag = Boolean.TRUE;        // 2
    }
	//Thread-B
    public void read() {
        if (flag) {                                     // 3
            System.out.println("---value = " + value);  // 4
        }
    }
}
// 1 happens-before 2, 3 happens-before 4
// 2 happens-before 3
// 1 happens-before 4
```

释:

- 操作 1 对 操作 4 一定可见, volatile将禁止重排序.

#### volatile的内存语义及实现

语义:

> 当写一个volatile变量时, JMM会把该线程对应的本地内存中的共享变量立即刷新的主存中
>
> 当读一个volatile变量时, JMM会把该线程对应的本地内存设置为无效, 直接从主内存中读取共享变量

为了实现volatile的内存语义JMM会限制重排序, 规则如下:

- 如果第一个操作为volatile读, 则不管第二个操作是啥, 都不能重排序. 这个操作确保volatile读之后的操作不会被编译器重排序到volatile读之前.
- 当第二个操作为volatile写是, 则不管第一个操作是啥, 都不能重排序. 这个操作确保volatile写之前的操作不会被编译器重排序到volatile写之后.
- 当第一个操作volatile写，第二操作为volatile读时，不能重排序 

volatile的底层实现是通过插入内存屏障，对于编译器来说，发现一个最优布置来最小化插入内存屏障的总数几乎是不可能的，所以，JMM采用了保守策略 :

- ==在每一个volatile写操作前面插入一个StoreStore屏障==

  - 作用: StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作都已经刷新到主内存中 

  

- ==在每一个volatile写操作后面插入一个StoreLoad屏障== 

  - 作用: StoreLoad屏障的作用是避免volatile写与后面可能有的volatile读/写操作重排序 

  

- ==在每一个volatile读操作后面插入一个LoadLoad屏障==

  - 作用: LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序 

  

- ==在每一个volatile读操作前面插入一个LoadStore屏障==

  - 作用: LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序

### Double Check Lock

### Synchronized





































































